#nullable enable

using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;

using static Poster.Interops.FileZone;

namespace Poster
{
	static partial class Helpers
	{
		/// <seealso cref="https://github.com/citizenmatt/UnblockZoneIdentifier" />
		/// <remarks>
		/// <para>(Main code is generated by ChatGPT-4o)</para>
		/// This can be done easily using <see cref="File.WriteAllLines(string, string[])"/>
		/// in .NET Core.
		/// </remarks>
		public static void MarkFile(string path, UrlZone urlZone = UrlZone.Internet)
		{
			SafeFileHandle handle = CreateFile(
				path + ":Zone.Identifier",
				0x40000000,  // GENERIC_WRITE
				0x00000001,  // FILE_SHARE_READ
				IntPtr.Zero,
				2,           // OPEN_ALWAYS
				0x00000080,  // FILE_ATTRIBUTE_NORMAL
				IntPtr.Zero);
			if (!handle.IsInvalid)
			{
				byte[] info = System.Text.Encoding.Default.GetBytes($"[ZoneTransfer]\r\nZoneId={(int)urlZone}\r\n");
				WriteFile(handle, info, (uint)info.Length, out _, IntPtr.Zero);

				handle.Close();
			}
			else
			{
				Debug.Assert(false, $"CreateFile failed with error {Marshal.GetLastWin32Error()}");
				// Do nothing.
			}
		}
	}
}

namespace Poster.Interops
{
	static class FileZone
	{
		[DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
		public static extern SafeFileHandle CreateFile(
			string lpFileName,
			uint dwDesiredAccess,
			uint dwShareMode,
			IntPtr lpSecurityAttributes,
			uint dwCreationDisposition,
			uint dwFlagsAndAttributes,
			IntPtr hTemplateFile);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool WriteFile(
			SafeFileHandle hFile,
			byte[] lpBuffer,
			uint nNumberOfBytesToWrite,
			out uint lpNumberOfBytesWritten,
			IntPtr lpOverlapped);

		public enum UrlZone : int
		{
			Invalid = -1,
			LocalMachine = 0,
			Intranet,
			Trusted,
			Internet,
			Untrusted
		}
	}
}
